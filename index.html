<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Traductor LSA con IA</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/vision_bundle.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 20px; }
        #videoPreview { transform: scaleX(-1); }
        #outputText { font-size: 1.5em; margin-top: 20px; }
    </style>
</head>
<body>
    <video id="videoPreview" width="640" height="480" autoplay></video>
    <div id="outputText"></div>

<script>
const videoElement = document.getElementById('videoPreview');
const outputDiv = document.getElementById('outputText');
let gestureRecognizer;
let lastGesture = '';
let sentence = [];
let lastDetectionTime = 0;

// Configuración del modelo de IA
const initializeGestureRecognizer = async () => {
    const vision = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
    );

    gestureRecognizer = await GestureRecognizer.createFromOptions(
        vision,
        {
            baseOptions: {
                modelAssetPath: "https://storage.googleapis.com/mediapipe-models/gesture_recognizer/gesture_recognizer/float16/1/gesture_recognizer.task",
                delegate: "GPU"
            },
            runningMode: "VIDEO",
            cannedGesturesClassifierOptions: {
                scoreThreshold: 0.7
            }
        }
    );
};

// Mapeo de gestos a texto (personalizable)
const gestureMapping = {
    'Thumb_Up': 'Hola',
    'Open_Palm': ' ',
    'Closed_Fist': 'A',
    'Victory': 'Bien',
    'Pointing_Up': 'Yo',
    'ILoveYou': 'Amor',
    'Thumb_Down': 'No',
    'Call_me': 'Llamar'
};

// Procesamiento en tiempo real
const processFrame = async () => {
    if (!gestureRecognizer) return;

    const now = performance.now();
    const results = gestureRecognizer.recognizeForVideo(videoElement, now);

    if (results.gestures.length > 0) {
        const gesture = results.gestures[0][0];
        const currentTime = Date.now();
        
        if (gesture.score > 0.8 && currentTime - lastDetectionTime > 1000) {
            const gestureName = gesture.categoryName;
            const text = gestureMapping[gestureName] || gestureName;
            
            updateSentence(text);
            lastDetectionTime = currentTime;
        }
    }
    
    requestAnimationFrame(processFrame);
};

// Construcción de frases
const updateSentence = (text) => {
    if (text === ' ') {
        sentence.push(' ');
    } else if (text === 'Backspace') {
        sentence.pop();
    } else {
        sentence.push(text);
    }
    
    outputDiv.textContent = sentence.join('')
        .replace(/\s+/g, ' ')
        .trim();
};

// Inicialización de la cámara
const startCamera = async () => {
    try {
        const stream = await navigator.mediaDevices.getUserMedia({
            video: { width: 640, height: 480, facingMode: "user" }
        });
        videoElement.srcObject = stream;
        
        await new Promise(resolve => {
            videoElement.onloadedmetadata = resolve;
        });
        
        await initializeGestureRecognizer();
        processFrame();
    } catch (error) {
        console.error('Error al acceder a la cámara:', error);
    }
};

// Manejo de secuencias complejas
const checkComplexGestures = (landmarks) => {
    // Lógica para detectar movimientos compuestos
    const wrist = landmarks[0];
    const fingerTips = landmarks.slice(8, 21);
    
    // Ejemplo: Detectar movimiento circular
    const movementPattern = fingerTips.map(tip => ({
        x: tip.x - wrist.x,
        y: tip.y - wrist.y
    }));
    
    if (isCircularMotion(movementPattern)) {
        updateSentence('Por favor');
    }
};

const isCircularMotion = (points) => {
    // Lógica de detección de movimiento circular
    const deltas = points.slice(1).map((p, i) => ({
        dx: p.x - points[i].x,
        dy: p.y - points[i].y
    }));
    
    const directionChanges = deltas.filter((d, i) => {
        if (i === 0) return false;
        const prev = deltas[i - 1];
        return (Math.sign(d.dx) !== Math.sign(prev.dx) || 
               (Math.sign(d.dy) !== Math.sign(prev.dy));
    });
    
    return directionChanges.length > 5;
};

// Iniciar aplicación
startCamera();

// Manejo de errores
window.addEventListener('error', (e) => {
    outputDiv.textContent = `Error: ${e.message}`;
});
</script>
</body>
</html>
