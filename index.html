<script>
const videoElement = document.getElementById('videoElement');
const canvasElement = document.getElementById('canvasElement');
const canvasCtx = canvasElement.getContext('2d');
const outputText = document.getElementById('outputText');

let gestureBuffer = [];
let lastDetectionTime = 0;
const gestureCooldown = 1000; // 1 segundo entre detecciones

const hands = new Hands({
    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
});

// Configuración mejorada
hands.setOptions({
    maxNumHands: 2,
    modelComplexity: 2, // Modelo más preciso
    minDetectionConfidence: 0.7,
    minTrackingConfidence: 0.7
});

hands.onResults(processResults);

const camera = new Camera(videoElement, {
    onFrame: async () => {
        await hands.send({image: videoElement});
    },
    width: 640,
    height: 480
});

camera.start();

function processResults(results) {
    canvasCtx.save();
    canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
    canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
    
    if (results.multiHandLandmarks) {
        results.multiHandLandmarks.forEach((landmarks, index) => {
            drawLandmarks(landmarks);
            const gesture = detectGesture(landmarks, results.multiHandedness[index]);
            updateGestureBuffer(gesture);
        });
    }
    canvasCtx.restore();
    
    updateOutputText();
}

function drawLandmarks(landmarks) {
    canvasCtx.fillStyle = '#00FF00';
    landmarks.forEach(landmark => {
        canvasCtx.beginPath();
        canvasCtx.arc(landmark.x * canvasElement.width,
                     landmark.y * canvasElement.height,
                     5, 0, 2 * Math.PI);
        canvasCtx.fill();
    });
}

function detectGesture(landmarks, handedness) {
    const fingersUp = checkFingersUp(landmarks);
    const isRightHand = handedness[0].label === 'Right';
    
    // Detección mejorada de letras
    if (isClosedFist(fingersUp)) return 'A';
    if (isOpenHand(fingersUp)) return 'B';
    if (isCShape(landmarks)) return 'C';
    if (isDShape(landmarks, fingersUp)) return 'D';
    if (isEShape(fingersUp)) return 'E';
    // Añadir más letras según LSA
    
    return '';
}

// Funciones de utilidad mejoradas
function checkFingersUp(landmarks) {
    const fingerJoints = [3, 6, 10, 14, 18];
    return fingerJoints.map((joint, index) => 
        landmarks[joint + 3].y < landmarks[joint].y
    );
}

function isClosedFist(fingersUp) {
    return fingersUp.every(finger => !finger);
}

function isOpenHand(fingersUp) {
    return fingersUp.slice(1).every(finger => finger);
}

function isCShape(landmarks) {
    const thumbTip = landmarks[4];
    const pinkyTip = landmarks[20];
    return Math.abs(thumbTip.x - pinkyTip.x) > 0.3;
}

function isDShape(landmarks, fingersUp) {
    return fingersUp[1] && !fingersUp.slice(2,4).some(f => f) &&
           distance(landmarks[8], landmarks[4]) < 0.1;
}

function distance(p1, p2) {
    return Math.sqrt(
        Math.pow(p1.x - p2.x, 2) +
        Math.pow(p1.y - p2.y, 2)
    );
}

function updateGestureBuffer(gesture) {
    const now = Date.now();
    if (gesture && now - lastDetectionTime > gestureCooldown) {
        gestureBuffer.push(gesture);
        lastDetectionTime = now;
        
        if (gestureBuffer.length > 5) {
            gestureBuffer.shift();
        }
    }
}

function updateOutputText() {
    const gestureCounts = gestureBuffer.reduce((acc, val) => {
        acc[val] = (acc[val] || 0) + 1;
        return acc;
    }, {});

    const mostFrequent = Object.entries(gestureCounts)
        .sort((a, b) => b[1] - a[1])[0];

    if (mostFrequent && mostFrequent[1] > 2) {
        currentText += mostFrequent[0];
        outputText.value = currentText;
        gestureBuffer = [];
    }
}

function clearText() {
    currentText = '';
    outputText.value = '';
    gestureBuffer = [];
}

window.onload = () => {
    canvasElement.width = videoElement.offsetWidth;
    canvasElement.height = videoElement.offsetHeight;
};
</script>
