<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Traductor LSA Offline</title>
    <!-- Versión local de MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/vision_bundle.js"></script>
</head>
<body>
    <video id="videoPreview" width="640" height="480" autoplay playsinline></video>
    <div id="outputText" style="font-size: 1.5em; margin-top: 20px;"></div>
    <div id="status" style="color: #666;">Inicializando...</div>

<script>
const videoElement = document.getElementById('videoPreview');
const outputDiv = document.getElementById('outputText');
const statusDiv = document.getElementById('status');

// 1. Configuración alternativa de modelos
const MODEL_CONFIG = {
    wasmPath: 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm/vision_wasm_internal.js',
    modelPath: 'https://teachablemachine.withgoogle.com/models/6OJsJ9Q7D/',
    gestureModel: 'gesture_recognizer.task'  // Archivo local alternativo
};

// 2. Inicialización mejorada
async function initializeModel() {
    try {
        statusDiv.textContent = "Descargando modelo...";
        
        const vision = await Vision.FilesetResolver.forVisionTasks(MODEL_CONFIG.wasmPath);
        
        // Intenta cargar primero desde repositorio alternativo
        try {
            gestureRecognizer = await Vision.GestureRecognizer.createFromOptions(
                vision,
                {
                    baseOptions: {
                        modelAssetPath: MODEL_CONFIG.modelPath + MODEL_CONFIG.gestureModel,
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO"
                }
            );
        } catch (onlineError) {
            statusDiv.textContent = "Usando modelo local de respaldo...";
            gestureRecognizer = await Vision.GestureRecognizer.createFromOptions(
                vision,
                {
                    baseOptions: {
                        modelAssetPath: './modelos/gesture_recognizer.task',  // Ruta local
                        delegate: "CPU"
                    },
                    runningMode: "VIDEO"
                }
            );
        }
        
        statusDiv.textContent = "Modelo cargado!";
        startCamera();
    } catch (error) {
        statusDiv.textContent = "Error crítico: Recarga la página";
        console.error("Error de modelo:", error);
    }
}

// 3. Gestión de cámara mejorada
async function startCamera() {
    try {
        const stream = await navigator.mediaDevices.getUserMedia({
            video: {
                width: { ideal: 640 },
                height: { ideal: 480 },
                facingMode: "user",
                frameRate: { ideal: 30 }
            }
        });
        
        videoElement.srcObject = stream;
        await videoElement.play();
        processFrames();
    } catch (error) {
        statusDiv.textContent = "Error de cámara: " + error.message;
    }
}

// 4. Procesamiento de frames optimizado
async function processFrames() {
    while (true) {
        if (!gestureRecognizer) await new Promise(resolve => setTimeout(resolve, 100));
        
        try {
            const results = gestureRecognizer.recognizeForVideo(videoElement, Date.now());
            updateGestures(results);
        } catch (error) {
            console.error("Error de frame:", error);
        }
        
        await new Promise(resolve => requestAnimationFrame(resolve));
    }
}

// 5. Detección precisa de gestos
function updateGestures(results) {
    if (!results || !results.gestures) return;
    
    const currentGestures = results.gestures
        .flat()
        .filter(g => g.score > 0.7)
        .map(g => g.categoryName);
    
    if (currentGestures.length > 0) {
        const translated = translateGestures(currentGestures);
        outputDiv.textContent = translated;
    }
}

// 6. Traducción mejorada
function translateGestures(gestures) {
    const GESTURE_MAP = {
        'Thumb_Up': 'Hola',
        'Open_Palm': ' ',
        'Closed_Fist': 'A',
        'Victory': 'B',
        // Agregar más mapeos según necesidad
    };
    
    return gestures.map(g => GESTURE_MAP[g] || '').join(' ');
}

// Iniciar
initializeModel();
</script>
</body>
</html>
